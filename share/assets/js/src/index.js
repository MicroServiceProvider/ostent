// Generated by CoffeeScript 1.9.2
(function() {
  require.config({
    shim: {
      bscollapse: {
        deps: ['jquery']
      },
      reactDOM: {
        deps: ['react']
      }
    },
    urlArgs: "bust=" + (new Date()).getTime(),
    paths: {
      domReady: 'vendor/requirejs-domready/2.0.1/domReady',
      jquery: 'vendor/jquery/2.1.4/jquery.min',
      bscollapse: 'vendor/bootstrap/3.3.5-collapse/bootstrap.min',
      react: 'vendor/react/0.14.0/react-with-addons.min',
      reactDOM: 'vendor/react/0.14.0/react-dom.min',
      jsdefines: 'lib/jsdefines'
    }
  });

  require(['jquery', 'react', 'reactDOM', 'jsdefines', 'domReady', 'bscollapse'], function($, React, ReactDOM, jsdefines) {
    var neweventsource, newwebsocket, update;
    neweventsource = function(onmessage) {
      var conn, init, sendSearch;
      conn = null;
      sendSearch = function(search) {
        console.log('SEARCH', search);
        conn.close();
        return window.setTimeout(init, 1000);
      };
      init = function() {
        var again;
        conn = new EventSource('/index.sse' + location.search);
        conn.onopen = function() {
          $(window).bind('popstate', (function() {
            sendSearch(location.search);
          }));
        };
        again = function(e) {
          if (!e.wasClean) {
            window.setTimeout(init, 5000);
          }
        };
        conn.onclose = function() {
          return console.log('sse closed (should recover)');
        };
        conn.onerror = function() {
          return console.log('sse errord (should recover)');
        };
        conn.onmessage = onmessage;
      };
      init();
      return {
        sendSearch: sendSearch,
        close: function() {
          return conn.close();
        }
      };
    };
    newwebsocket = function(onmessage) {
      var conn, init, sendSearch;
      conn = null;
      sendSearch = function(search) {
        console.log('Search', search);
        if ((conn == null) || conn.readyState === conn.CLOSING || conn.readyState === conn.CLOSED) {
          init();
        }
        if ((conn == null) || conn.readyState !== conn.OPEN) {
          console.log('Not connected, cannot send search', search);
          return null;
        }
        return conn.send(JSON.stringify({
          Search: search
        }));
      };
      init = function() {
        var again, hostport;
        hostport = window.location.hostname + (location.port ? ':' + location.port : '');
        conn = new WebSocket('ws://' + hostport + '/index.ws');
        conn.onopen = function() {
          sendSearch(location.search);
          $(window).bind('popstate', (function() {
            sendSearch(location.search);
          }));
        };
        again = function(e) {
          if (!e.wasClean) {
            window.setTimeout(init, 5000);
          }
        };
        conn.onclose = again;
        conn.onerror = again;
        conn.onmessage = onmessage;
      };
      init();
      return {
        sendSearch: sendSearch,
        close: function() {
          return conn.close();
        }
      };
    };
    update = function() {
      var el, els, onmessage, render_define;
      render_define = function(el) {
        var cl;
        cl = jsdefines[$(el).attr('data-define')];
        return ReactDOM.render(React.createElement(cl), el);
      };
      els = (function() {
        var i, len, ref, results;
        ref = $('.updates');
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          el = ref[i];
          results.push(render_define(el));
        }
        return results;
      })();
      onmessage = function(event) {
        var data, i, len;
        data = JSON.parse(event.data);
        if (data == null) {
          return;
        }
        if ((data.Reload != null) && data.Reload) {
          window.setTimeout((function() {
            return location.reload(true);
          }), 5000);
          window.setTimeout(window.updates.close, 2000);
          console.log('in 5s: location.reload(true)');
          console.log('in 2s: window.updates.close()');
          return;
        }
        if (data.Error != null) {
          console.log('Error', data.Error);
          return;
        }
        for (i = 0, len = els.length; i < len; i++) {
          el = els[i];
          el.NewState(data);
        }
      };
      window.updates = newwebsocket(onmessage);
    };
    return require(['domReady', 'jquery'], function(domReady, $) {
      return domReady(function() {
        var param;
        if (!((function() {
          var i, len, ref, results;
          ref = location.search.substr(1).split('&');
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            param = ref[i];
            if (param.split('=')[0] === 'still') {
              results.push(42);
            }
          }
          return results;
        })()).length) {
          update();
        }
        return null;
      });
    });
  });

}).call(this);
