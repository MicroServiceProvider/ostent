let $          = require('jquery'),
    React      = require('react'),
    ReactDOM   = require('react-dom'),
    ReactPRM   = require('react-prm'),
    SparkLines = require('react-sparklines');
let ReactPureRenderMixin = ReactPRM,
    Sparklines      = SparkLines.Sparklines,
    SparklinesLine  = SparkLines.SparklinesLine,
    SparklinesSpots = SparkLines.SparklinesSpots;

var sparklines = React.createClass({
  mixins: [ReactPureRenderMixin],
  getInitialState: function() {return {data:[], limit: 120, width: 240};},
  componentDidUpdate: function (_, prevState) {
    var root = ReactDOM.findDOMNode(this.refs.root);
    if (root != null && prevState.width != root.offsetWidth) {
      this.setState({width: root.offsetWidth, limit: Math.round(root.offsetWidth/2)});
    }
  },
  render: function() {
    return <div className="height-1rem" ref="root"
      ><Sparklines
               data={this.state.data}
               limit={this.state.limit}
               width={this.state.width}
               height={24}
               // margin={0} will make spots overlap boundaries
      >
        <SparklinesLine />
        <SparklinesSpots spotColors={ {'-1': 'green', '1': 'red'} } />
      </Sparklines></div>;
  }
});

function sl(i) { return React.createElement(sparklines, {ref: i}); }

let jsdefines = {};
jsdefines.StateHandlingMixin = { // requires .Reduce method
  getInitialState: function() {
    return this.StateFrom(Data); // global Data
  },
  NewState: function(data) {
    let state = this.StateFrom(data);
    if (state != null) {
      this.setState(state);
    }
    if (this.props.SparkSubkey == null || this.List == null) {
      return;
    }
    var rkeys = Object.keys(this.refs);
    if (rkeys.length == 0) {
      return;
    }
    var list = this.List(state);
    rkeys.forEach(function(rk) {
      var ref = this.refs[rk], lrow = list[+rk];
      if (ref == null || lrow == null) {
        return;
      }
      var newValue = +lrow[this.props.SparkSubkey];
      var rstate = {}, limit;
      if (ref.state != null) {
        rstate.data = ref.state.data.slice(); // NB
        limit = ref.state.limit;
      }
      if (rstate.data == null) {
        rstate.data = [];
      }
      rstate.data.push(newValue);
      if (limit != null && rstate.data.length > limit) {
        rstate.data = rstate.data.slice(-limit);
      }
      this.refs[rk].setState(rstate);
    }, this);
  },
  StateFrom: function(data) {
    let state = this.Reduce(data);
    if (state != null) {
      for (let key in state) {
        if (state[key] == null) {
          delete state[key];
        }
      }
    }
    return state;
  }
};
jsdefines.HandlerMixin = {
  handleClick: function(e) {
    let href = e.target.getAttribute('href');
    if (href == null) {
      href = $(e.target).parent().get(0).getAttribute('href');
    }
    history.pushState({}, '', href);
    window.updates.sendSearch(href);
    e.stopPropagation();
    e.preventDefault();
    return void 0;
  }
};

// transformed from define_* templates:
{{range $d := .Defines}}{{$q := printf "%q" $d.Iterable}}
jsdefines.{{$d.ShortName}} = React.createClass({
  mixins: [ReactPureRenderMixin, jsdefines.StateHandlingMixin, jsdefines.HandlerMixin],
  {{if .NeedList}}{{/*
*/}}List: function(data) {
    let list;
    if (data == null || data[{{$q}}] == null || (list = data[{{$q}}].List) == null) {
      return [];
    }
    return list;
  },
  {{end}}{{/*
*/}}Reduce: function(data) {
    return {
      {{if .UsesParams}}params: data.params,
      {{end}}{{/*
*/}}{{$d.Iterable}}: data.{{$d.Iterable}}
    };
  },
  render: function() {
    let Data = this.state; // shadow global Data
    return {{$d.JSX}};
  }
});
{{end}}

module.exports = jsdefines;

// Local variables:
// js-indent-level: 2
// js2-basic-offset: 2
// End:
